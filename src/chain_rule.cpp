#include "chain_rule.hpp"
#include <sstream>

namespace iptables {

ChainRule::ChainRule(const std::string& target_chain,
                     Direction direction,
                     const InterfaceConfig& interface,
                     const std::vector<std::string>& subnets,
                     const std::string& section_name)
    : Rule(direction, Action::Accept, interface, subnets)  // Use Accept as placeholder since we jump to chain
    , target_chain_(target_chain)
    , section_name_(section_name) {
    // Chain rules implement the iptables jump mechanism (-j chain_name)
    // This allows modular rule organization by delegating packet processing to custom chains
    // The Action::Accept parameter is a placeholder since the actual action depends on the target chain
}

std::string ChainRule::getComment() const {
    // Generate a standardized comment for chain rule identification
    // This comment format allows rule management systems to identify and track chain jumps
    // The format embeds the target chain name for easy parsing and management
    std::string details = "chain_call:" + target_chain_;
    
    // Use the centralized comment building function for consistency across rule types
    // This ensures all YAML-managed rules follow the same identification pattern
    return buildYamlComment(section_name_, "chain_call", details, "any");
}

std::vector<std::string> ChainRule::buildIptablesCommand() const {
    std::vector<std::string> args;
    
    // Build standard iptables rule structure for chain jumping
    // Chain rules operate in the filter table by default (no -t specification needed)
    args.push_back("-A");                    // Append rule to chain
    args.push_back(directionToString());     // Specify target chain (INPUT/OUTPUT/FORWARD)
    
    // Add interface-based filtering if specified
    // Interface restrictions ensure the chain jump only occurs for matching interfaces
    // This is useful for interface-specific rule sets or network segmentation
    addInterfaceArgs(args);
    
    // Add subnet-based filtering if specified
    // Subnet restrictions allow conditional chain jumping based on source/destination networks
    // This enables network-based rule organization and access control
    addSubnetArgs(args);
    
    // Implement the chain jump using iptables -j (jump) target
    // This transfers packet processing to the specified custom chain
    // If the target chain doesn't exist, iptables will return an error
    args.push_back("-j");
    args.push_back(target_chain_);
    
    // Add identification comment for rule management
    // This allows the application to identify and remove chain rules during cleanup
    addCommentArgs(args, getComment());
    
    return args;
}

bool ChainRule::matches(const std::string& comment) const {
    // Implement flexible comment matching for rule identification and management
    // This supports both current and legacy comment formats for backward compatibility
    
    // Primary matching: use the current comment format generated by getComment()
    // This is the preferred method for newly created rules
    std::string expected_comment = getComment();
    bool primary_match = comment.find(expected_comment) != std::string::npos;
    
    // Fallback matching: support legacy YAML comment format
    // This ensures compatibility with rules created by older versions of the application
    // Format: "YAML:section_name:chain_call:target_chain"
    std::string legacy_pattern = "YAML:" + section_name_ + ":chain_call:" + target_chain_;
    bool legacy_match = comment.find(legacy_pattern) != std::string::npos;
    
    // Return true if either matching method succeeds
    // This provides robust rule identification across different comment formats
    return primary_match || legacy_match;
}

} // namespace iptables 